import { PUMP_FLOWRATE_GAIN, PUMP_PRESSURE_GAIN, PUMP_VELOCITY_GAIN } from '../types';
import { setTargetBedHeight } from './canvas';
import { secantMethod } from './helpers';
import State from './state';

const InitialBedHeight = 5.0; // cm
const mu = 1.002; // mPa s
const rho = .997; // g / cc
const rho_p = 2.4; // g / cc
const grav = 981; // cm / s2
const ParticleDiameter = 0.107; // cm
const Init_VoidFrac = 0.39;

var minFluidizeVelocity=0;
function initializeCalculations() {
    const a = 1.75 * rho * ParticleDiameter;
    const b = 150 * mu * (1 - Init_VoidFrac) / 100;
    const c = -(rho_p - rho) * grav * Init_VoidFrac**3 * ParticleDiameter**2;
    // minFluidizeVelocity = roots([a,b,c])
    const x1 = (-b + Math.sqrt(b*b - 4*a*c)) / 2 / a;
    const x2 = (-b - Math.sqrt(b*b - 4*a*c)) / 2 / a;
    minFluidizeVelocity = (x1 > 0) ? x1 : x2;
}
initializeCalculations();

/**
 * Calculate the pressure generated by the pump
 * @returns pressure from pump in cm water
 */
export function pumpPressure() {
    return PUMP_PRESSURE_GAIN * State.valveLift;
}

/**
 * Return the flowrate of the tank given a fluidization velocity
 * @param lift 
 * @returns 
 */
export function flowrate(lift: number) {
    return lift * PUMP_FLOWRATE_GAIN;
}

/**
 * Calculates the pressure drop and sets the bed height
 * @returns pressure drop across bed in UNITS (positive)
 */
export function pressureDrop(lift?: number, returnHeight=false) {
    var dbMode = true;
    if (lift == undefined) {
        lift = State.valveLift;
        dbMode = false;
    }
    const sup_vel = lift * PUMP_VELOCITY_GAIN; // Superficial velocity, cm/s

    // Packed regime
    if (sup_vel < minFluidizeVelocity) {
        // Bed height is fixed
        if (!dbMode) setTargetBedHeight(InitialBedHeight);
        
        // Use eq 1 to solve pressure
        const p = 150 * mu * InitialBedHeight / ParticleDiameter**2 * (1 - Init_VoidFrac)**2 / Init_VoidFrac**3 * sup_vel / 100 +
            1.75 * InitialBedHeight * rho / ParticleDiameter  *  (1 - Init_VoidFrac) / Init_VoidFrac**3 * sup_vel**2; // mPa
        const p_cmw = p / rho / grav;

        // console.log(`Packed bed regime; Pressure drop = ${p} mPa = ${p_cmw} cm water`);
        if (returnHeight) return InitialBedHeight;
        return p_cmw;
    }

    // Fluidized regime
    else if (sup_vel <= 6) {
        const ergun = (lf: number) => {
            // Calculate porosity
            const ep = 1 - InitialBedHeight / lf * (1 - Init_VoidFrac);
            // Solve eq 3 for root
            return 1.75 * rho * ParticleDiameter * sup_vel**2 +
                1.5 * mu * (1 - ep) * sup_vel -
                (rho_p - rho) * grav * ep**3 * ParticleDiameter**2;
        };

        const h = secantMethod(ergun, 1, 10);
        
        const ep = 1 - InitialBedHeight / h * (1 - Init_VoidFrac);
        const p = (rho_p - rho) * grav * h * (1 - ep);
        
        if (!dbMode) setTargetBedHeight(h);
        if (returnHeight) return h;
        return p / rho / grav;
    }

    // Repacked regime
    else {
        const dx = sup_vel - 6;
        const dy = dx * 15.0;
        // console.log('Repacked regime');
        if (!dbMode) setTargetBedHeight(14.5 + 10*dx);
        if (returnHeight) return 14.5 + 5*dx;
        return 4.3 + dy; 
    }
}
