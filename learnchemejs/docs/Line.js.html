<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Line.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Line.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {Text} from "./Text.js";
import {randomID, isBetween, getDist} from "./sky-helpers.js";
import {LAYERS} from "./GraphCanvasController.js";

const IDLENGTH = 16;

/**
    @param {object} args Object-like object of input arguments.
    @param {list} args.points List of {@link Point} constructor argument objects
    @param {string} [args.color="black"]
    @param {float} [args.width=1]
    @param {boolean} [args.answer=false]
    @param {boolean} [args.correctanswer=false]
    @param {object} [args.fill] Fill the region enclosed by the line
    @param {string} args.fill.color Color to fill the region
    @param {float} args.fill.opacity Opacity of the color (0 to 1)
    @param {object} [args.label] Label to go beside the line
    @param {string} [args.label.text] Label contents
    @param {number} [args.label.independent] Location of text (of independent variable)
    @param {number} [args.label.dependent] Location of text (of dependent variable)
*/
export class Line {
    constructor(args) {
        /**
            @name Line#ID
            @type string
            @desc (Probably) unique identifier for line. Generated by {@link randomID}.
        */
        this.ID = randomID(IDLENGTH);
        /**
            @name Line#color
            @type string
            @default "black"
            @desc Line color.
        */
        this.color = "black";
        /**
            @name Line#width
            @type number
            @default 2
            @desc Line width.
        */
        this.width = 2;
        /**
            @name Line#tension
            @type number
            @default 0
            @desc Tension of spline drawn through points (0 is linear)
        */
        this.tension = 0;
        /**
            @name Line#layer
            @type number
            @default 1
            @desc Layer to draw element onto
        */
        this.layer = LAYERS.UNDER;
        /**
            @name Line#answer
            @type boolean
            @default false
            @desc Is this line submitted as an answer to the question?
        */
        this.answer = false;
        /**
            @name Line#correctanswer
            @type boolean
            @default false
            @desc Is this line a correct answer?
        */
        this.correctanswer = false;
        // Fill values from provided arguments
        for (let key of Object.keys(args)) {
            this[key] = args[key];
        }
    }

    draw(context) {
        context.save();
        context.beginPath();
        context.globalAlpha = 1;
        context.strokeStyle = this.color;
        context.lineWidth = this.width;
        if (this.dashes) {
            context.setLineDash([this.dashes.dash, this.dashes.space]);
        }
        let first = true;
        // Connect points
        if (this.tension == 0) {
            // Draw point-to-point
            for (let pt of this.points) {
                if (isBetween(pt.rawx, this.graphinfo.graphleft, this.graphinfo.graphright) &amp;&amp;
                    isBetween(pt.rawy, this.graphinfo.graphtop, this.graphinfo.graphbottom)) {
                    if (first) {
                        // Move to start of line
                        context.moveTo(pt.rawx, pt.rawy);
                    } else {
                        // Draw segment
                        context.lineTo(pt.rawx, pt.rawy);
                        context.stroke();
                    }
                    first = false;
                }
            }
        } else {
            this.drawSpline(context, this.tension);
        }
        // Shade tolerance of points
        for (let pt of this.points) {
            if (this.correctanswer &amp;&amp; pt.answer) {
                // Draw ellipse
                context.beginPath();
                context.strokeStyle = "green";
                context.ellipse(pt.rawx, pt.rawy, this.tolerance.x*pt.graphinfo.x.scale, this.tolerance.y*-pt.graphinfo.y.scale, 0, 0, 2*Math.PI, false);
                //context.stroke();
                // Fill circle
                context.fillStyle = "green";
                context.globalAlpha = 0.3;
                context.fill();
            }
        }
        if (this.fill) {
            context.fillStyle = this.fill.color;
            context.globalAlpha = this.fill.opacity;
            context.fill();
        }
        if (this.label) {
            let pos = {"graphinfo": this.graphinfo};
            pos[this.independent.symbol] = this.label.independent;
            pos[this.dependent.symbol] = this.label.dependent;
            new Text({
                "text": this.label.text,
                "position": pos,
                "align": "center",
                "color": this.color,
                "rotate": this.label.rotate
            }).draw(context);
        }
        context.restore();
    }
    /**
    *   Generates control points for use in {@link Line#drawSpline}
    */
    getControlPoints(x0, y0, x1, y1, x2, y2, t){
        //  x0,y0,x1,y1 are the coordinates of the end (knot) pts of this segment
        //  x2,y2 is the next knot -- not connected here but needed to calculate p2
        //  p1 is the control point calculated here, from x1 back toward x0.
        //  p2 is the next control point, calculated here and returned to become the
        //  next segment's p1.
        //  t is the 'tension' which controls how far the control points spread.

        //  Scaling factors: distances from this knot to the previous and following knots.
        var d01 = Math.sqrt(Math.pow(x1-x0, 2)+Math.pow(y1-y0, 2));
        var d12 = Math.sqrt(Math.pow(x2-x1, 2)+Math.pow(y2-y1, 2));

        var fa = t*d01/(d01+d12);
        var fb = t-fa;

        var p1x = x1+fa*(x0-x2);
        var p1y = y1+fa*(y0-y2);

        var p2x = x1-fb*(x0-x2);
        var p2y = y1-fb*(y0-y2);

        return [p1x, p1y, p2x, p2y]
    }
    /**
    *   Draws a spline with specified tension &lt;br>
    *   Using example at: http://scaledinnovation.com/analytics/splines/aboutSplines.html
    *   @param {context} context Canvas context to draw onto
    *   @param {float} t Tension to draw the spline with
    */
    drawSpline(context, t) {
        let pts = [];
        for (let pt of this.points) {
            pts.push(pt.rawx);
            pts.push(pt.rawy);
        }
        let cp = [];
        const n = pts.length;
        for (let i = 0; i &lt; n - 4; i += 2) {
            cp = cp.concat(this.getControlPoints(pts[i], pts[i+1], pts[i+2], pts[i+3], pts[i+4], pts[i+5], t));
        }
        for (var i = 2; i &lt; pts.length - 5; i += 2) {
//            if (isBetween(pts[i], this.graphinfo.graphleft, this.graphinfo.graphright) &amp;&amp;
//                isBetween(pts[i+1], this.graphinfo.graphtop, this.graphinfo.graphbottom) &amp;&amp;
//                isBetween(pts[i+2], this.graphinfo.graphleft, this.graphinfo.graphright) &amp;&amp;
//                isBetween(pts[i+3], this.graphinfo.graphtop, this.graphinfo.graphbottom)) {
                context.beginPath();
                context.moveTo(pts[i], pts[i+1]);
                context.bezierCurveTo(cp[2*i-2], cp[2*i-1], cp[2*i], cp[2*i+1], pts[i+2], pts[i+3]);
                context.stroke();
                context.closePath();
//            }
        }
        //  For open curves the first and last arcs are simple quadratics.
//        if (isBetween(pts[0], this.graphinfo.graphleft, this.graphinfo.graphright) &amp;&amp;
//            isBetween(pts[1], this.graphinfo.graphtop, this.graphinfo.graphbottom)) {
            context.beginPath();
            context.moveTo(pts[0], pts[1]);
            context.quadraticCurveTo(cp[0], cp[1], pts[2], pts[3]);
            context.stroke();
            context.closePath();
//        }
//        if (isBetween(pts[n-4], this.graphinfo.graphleft, this.graphinfo.graphright) &amp;&amp;
//            isBetween(pts[n-3], this.graphinfo.graphtop, this.graphinfo.graphbottom)) {
            context.beginPath();
            context.moveTo(pts[n-2], pts[n-1]);
            context.quadraticCurveTo(cp[2*n-10], cp[2*n-9], pts[n-4], pts[n-3]);
            context.stroke();
            context.closePath();
//        }
    }
    /**
        @return {int} The number of line segments
    */
    segments() {
        return this.points.length-1;
    }
    /**
        @return {float} The total distance covered by the line from point to point
    */
    distance() {
        let sum = 0;
        for (let i = 1; i &lt; this.points.length; i++) {
            sum += getDist(this.points[i-1], this.points[i]);
        }
        return sum;
    }
    /**
        @return {object} The internal data of the line
    */
    data() {
        let r = {};
        for (let k of Object.keys(this)) {
            r[k] = this[k];
        }
        return r;
    }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CanvasElement.html">CanvasElement</a></li><li><a href="GraphCanvasController.html">GraphCanvasController</a></li><li><a href="GraphInfo.html">GraphInfo</a></li><li><a href="Line.html">Line</a></li><li><a href="Modal.html">Modal</a></li><li><a href="Point.html">Point</a></li><li><a href="ProblemController.html">ProblemController</a></li><li><a href="Question_Question.html">Question</a></li><li><a href="QuestionElement.html">QuestionElement</a></li><li><a href="Text.html">Text</a></li><li><a href="TextboxElement.html">TextboxElement</a></li><li><a href="TextElement.html">TextElement</a></li><li><a href="ZCanvas.html">ZCanvas</a></li></ul><h3>Global</h3><ul><li><a href="global.html#checkCookie">checkCookie</a></li><li><a href="global.html#constrain">constrain</a></li><li><a href="global.html#DOM">DOM</a></li><li><a href="global.html#FindRoot">FindRoot</a></li><li><a href="global.html#FindRootMulti">FindRootMulti</a></li><li><a href="global.html#generateVariables">generateVariables</a></li><li><a href="global.html#getAngle">getAngle</a></li><li><a href="global.html#getCookie">getCookie</a></li><li><a href="global.html#getDist">getDist</a></li><li><a href="global.html#getRandom">getRandom</a></li><li><a href="global.html#ifTF">ifTF</a></li><li><a href="global.html#isBetween">isBetween</a></li><li><a href="global.html#isIterable">isIterable</a></li><li><a href="global.html#randomID">randomID</a></li><li><a href="global.html#recursiveExists">recursiveExists</a></li><li><a href="global.html#recursiveFind">recursiveFind</a></li><li><a href="global.html#recursiveNumberfy">recursiveNumberfy</a></li><li><a href="global.html#recursiveReplace">recursiveReplace</a></li><li><a href="global.html#roundTo">roundTo</a></li><li><a href="global.html#setCookie">setCookie</a></li><li><a href="global.html#VAR">VAR</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Mon Nov 05 2018 12:57:58 GMT-0700 (Mountain Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
